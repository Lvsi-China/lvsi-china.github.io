---
layout:     post
title:      【译】解释Python内置字典Dict
subtitle:   Python , Python Dict
date:       2019-01-26
author:     Grape
header-img: 
catalog: true
tags:
    - Python
---

# 解释Python内置字典Dict

> 原文 [Inside python dict — an explorable explanation](https://just-taking-a-ride.com/inside_python_dict/chapter1.html)<br/>
> 译者：[Grape](https://github.com/WGrape)

## 内容

1. 在list中高效搜索
2. [为什么hash tables称为hash tables？](https://just-taking-a-ride.com/inside_python_dict/chapter2.html)
3. [自己制作一个 python dict](https://just-taking-a-ride.com/inside_python_dict/chapter3.html)
4. [python dict 是如何工作的？](https://just-taking-a-ride.com/inside_python_dict/chapter4.html)

## 介绍
嗨！这是Python词典的可探索解释。此页面是动态和交互式的 - 您可以插入数据并查看算法如何工作。（一旦javascript加载）

首先，假设我们有一个简单的不同整数列表（如果需要，可以更改它 - 页面将更新）：

Python列表实际上是数组 - 连续的内存块。名称“list”可能会误导那些了解双链表但又不熟悉Python的人。您可以将Python列表描绘为一行插槽，其中每个插槽可以包含一个Python对象：

要检查列表中是否存在元素，我们可以使用以下in运算符: ,返回或者。在引擎盖下，这个简短的片段进行线性扫描。这可能是很多工作。要看到这一点，让我们在Python中重新实现它。 number in simple_list TrueFalse

假设我们在原始列表中寻找以下数字：25

（可视化是交互式的。按钮允许您单步执行代码。请注意，时间滑块是可拖动的 - 随时可以回放时间或向前移动。另外，请随意混淆输入和原始列表 - 可视化将自动更新）

线性扫描有什么不好的？如果我们有一百万个不同的数字，在最坏的情况下，我们可能需要扫描整个列表。但扫描一些元素并没有什么大不了的。我们需要有一些顺序和可预测性来快速进行搜索。我们需要知道搜索元素的位置。

Python dict实现基本上是对列表的扫描（但是非常奇怪的扫描）。我们将逐步在Python字典中构建实际的算法和数据结构，从上面的代码开始，这是有意冗长的。

## 第1章 在列表中有效搜索
Python dict是键值对的集合。而且，最重要的部分是处理密钥。密钥需要以有效搜索，插入和删除的方式进行组织。

在本章中，为了简单起见，我们不会有任何值，“keys”只是简单的整数。因此，简化的问题是检查列表中是否存在数字，但我们必须快速执行此操作。我们将在接下来的章节中解决实际问题。但就目前而言，请耐心等待。

通过索引访问单个元素非常快。仅访问少数元素也会很快。我们不希望每次查找数字时都对整个列表进行线性扫描，因此我们需要以巧妙的方式组织数据。

这是如何做。

让我们首先创建一个新的插槽列表。每个插槽将保留原始列表中的数字或为空（空插槽将保留None）。我们将使用数字本身来计算插槽的索引。最简单的方法是将余数除以：并将我们的数字放在带有此索引的插槽中。要检查数字是否存在，我们可以再次计算插槽索引并查看它是否为空。 numberlen(the_list) number % len(the_list)

然而，这种方法会起作用吗？不是完全。例如，50将获得相同的插槽索引（3）2，它将被覆盖。像这样的情况称为碰撞。

为了使这种方法可行，我们需要以某种方式解决冲突。让我们执行以下操作：如果插槽已经被其他一些数字占用，我们将只检查它后面的插槽。如果那个插槽是空的，我们将把数字放在那里。但是，如果那个插槽也被占用了怎么办？再一次，我们将继续检查下一个插槽。我们将继续重复这个过程，直到我们最终遇到一个空位。这个过程叫做探测。因为我们是线性的，所以它被称为线性探测。在代码中，我们将其写为，因此它将回绕到最后一个索引的开头： (idx + 1) % len(simple_list)

如果我们使新列表与原始列表的大小相同，我们将发生太多冲突。如果我们将其大10倍，我们将会发生很少的碰撞，但是我们会浪费大量的内存。那应该是多大的尺寸？我们希望在不消耗太多内存但也没有太多碰撞的情况下达到最佳点。原始列表大小的两倍是合理的。

让我们使用这种方法转换原始列表（在阅读此代码时，请记住这是一个不同数字的列表，因此我们不需要处理重复项）。 original_list

为了搜索数字，我们回溯插入它所需的所有步骤：我们从插槽开始并进行线性探测。我们要么最终找到号码，要么打一个空位。后一种情况意味着该号码不存在。 number % len(new_list)

假设我们想要搜索2

基于数值计算索引并通过线性探测解决碰撞是一个非常强大的想法。我们刚刚实现的是一个简单的哈希表 （更多关于下一章中的术语）。Python dict在内部使用哈希表，虽然是一个更复杂的变体。

我们还没有讨论添加更多的元素（如果表溢出会发生什么？），删除元素（删除没有跟踪的元素会导致出现漏洞，这不会导致搜索算法在许多情况下过早停止吗？ ），也许最重要的是，处理整数以外的对象 - 字符串，元组，浮点数。我们将在接下来的章节中做到这一点。

**通过单独的链接进行碰撞解决**

有一种不同的冲突解决方法，称为单独链接。这也是一种常用的好策略。但这不是Python如何解决碰撞的问题，因此它超出了这种解释的范围。

**关于解释的几个注释**

首先，这个解释讨论了dict它在CPython中的实现- Python语言的“默认”和最常见的实现（如果你不确定你使用什么实现，几乎可以肯定是CPython）。其他一些实现是PyPy，Jython和IronPython。dicts在每个实现中的工作方式可能类似于CPython（在PyPy的情况下）或与CPython（在Jython的情况下）非常不同。

其次，即使CPython中的dict是用C实现的，这个解释也使用Python代码片段。本页面的目的是帮助您理解算法和底层数据结构，而不是C代码的细节（这些细节也很有趣 - 它们只是超出了本解释的范围）。

